
<link rel="stylesheet" type="text/css" href="job-manager/css/app" />
<link rel="stylesheet" type="text/css" href="job-manager/css/fontawesome" />


<script src="job-manager/js/vue"></script>
<script src="job-manager/js/axio"></script>
<script src="job-manager/js/sweetalert"></script>
<script src="job-manager/js/jsoneditor"></script>


<script type="text/x-template" id="modal-template">
    <transition name="modal">
        <div class="modal-mask">
            <div class="modal-wrapper">
                <div class="modal-container">

                    <div class="modal-header">
                        <slot name="header">
                            default header
                        </slot>
                    </div>

                    <div class="modal-scroll">

                        <div class="modal-body">
                            <slot name="body">
                                default body
                            </slot>
                        </div>
                    </div>

                    <div class="modal-footer">
                        <button class="modal-default-button btn btn-danger pull-left" @click="closeModal">
                            <i class="fa fa-window-close" aria-hidden="true"></i>
                            Close
                        </button>

                        <slot name="footer">

                            <button class="modal-default-button btn btn-success pull-right" @click="closeModal">
                                Save
                            </button>
                        </slot>
                    </div>
                </div>
            </div>
        </div>
    </transition>
</script>

<div id="app">

    <modal v-show="showModal" @close="closeModal">
        <template v-slot:header>
            <h3>{{ title }}</h3>
        </template>
        <template v-slot:body>
            <form id="formJob">

                <input type="hidden" id="Guid" name="Guid" v-model="job.Guid" />

                <div class="form-group">
                    <label for="JobType">Job Type</label>

                    <select id="JobType" name="JobType" class="form-control" v-model="job.JobType" @change="onJobTypeChange">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in jobTypes" :key="index" :value="item.Value">{{ item.Text }}</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="MisfireHandlingMode">Misfire Handling Mode</label>
                    <select id="MisfireHandlingMode" name="MisfireHandlingMode" class="form-control" v-model="job.MisfireHandlingMode">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in misfireHandlingModes" :key="index" :value="item.Value">{{ item.Text }}</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="Id">Job Id</label>
                    <input type="text" class="form-control" v-model="job.Id" id="Id" name="Id" placeholder="Enter Job Id">
                </div>
                <div class="form-group">
                    <label for="TimeZoneId">Time Zone</label>
                    <select id="TimeZoneId" name="TimeZoneId" class="form-control" v-model="job.TimeZoneId" data-live-search="true">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in timeZones" :key="index" :value="item.Item1">{{ item.Item2 }}</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="Cron">Cron</label>
                    <input type="text" class="form-control" v-model="job.Cron" id="Cron" name="Cron" placeholder="Example: */5 * * * * *">

                </div>


                <div class="form-group">
                    <label for="LimitConcurrency">Limit Concurrency Execution</label>
                    <select id="LimitConcurrency" name="LimitConcurrency" class="form-control" v-model="job.LimitConcurrency">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>

                <div class="form-group" v-show="job.LimitConcurrency === 'true' || job.LimitConcurrency === true">
                    <label for="MaxConcurrentTasks">Max Concurrent Tasks</label>
                    <input type="number" maxlength="3" min="1" max="999" class="form-control" v-model="job.MaxConcurrentTasks" id="MaxConcurrentTasks" name="MaxConcurrentTasks" placeholder="Example: 3">
                </div>

                <div class="form-group" v-show="job.JobType === 'MethodCall'">
                    <label for="Type">Type</label>

                    <v-select v-model="job.Type"
                              :options="['Option 1', 'Option 2', 'Option 3', 'Option 4']"
                              placeholder="Bir seçenek seçin">
                    </v-select>

                    <select id="Type" name="Type" class="form-control selectpicker" data-live-search="true" v-model="job.Type" @change="onClassChange">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in assemblyTypes" :key="index" :value="item">{{ item }}</option>

                    </select>
                </div>
                <div class="form-group" v-show="job.JobType === 'MethodCall' &&  job.Type!=''">
                    <label for="Method">Method</label>
                    <select id="Method" name="Method" class="form-control" v-model="job.Method" @change="getAssemblyTypeMethodJsonSchema">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in assemblyTypeMethods" :key="index" :value="item">{{ item }}</option>
                    </select>
                </div>
                <div class="form-group" v-show="job.JobType === 'MethodCall' && job.Type !=='' &&  job.Method !='' && methodParametersIsExist === true">
                    <label for="methodParametersJsonEditor">Method Parameters</label>
                    <input type="hidden" id="MethodParameters" name="MethodParameters" v-model="job.MethodParameters">
                    <div id="methodParametersJsonEditor"></div>
                </div>
                <div class="form-group" v-show="job.JobType === 'WebRequest'">
                    <label for="HostName">HostName</label>
                    <input type="text" class="form-control" v-model="job.HostName" id="HostName" name="HostName" placeholder="Example: http://HostName.com">
                </div>
                <div class="form-group" v-show="job.JobType === 'WebRequest'">
                    <label for="UrlPath">Path</label>
                    <input type="text" class="form-control" v-model="job.UrlPath" id="UrlPath" name="UrlPath" placeholder="Example: /api/get-products">
                </div>
                <div class="form-group" v-show="job.JobType === 'WebRequest'">
                    <label for="HttpMethod">Http Method</label>
                    <select id="HttpMethod" name="HttpMethod" class="form-control" v-model="job.HttpMethod" @change="onHttpMethodChange">
                        <option value="">Please select</option>
                        <option v-for="(item, index) in httpMethods" :key="index" :value="item">{{ item }}</option>
                    </select>
                </div>
                <div class="form-group table-group" v-show="job.JobType === 'WebRequest'">

                    <input type="hidden" id="HeaderParameters" name="HeaderParameters" v-model="job.HeaderParameters">
                    <div id="headerParametersJsonEditor"></div>
                </div>
                <div class="form-group" v-show="job.JobType === 'WebRequest' && job.HttpMethod!=''">
                    <label for="BodyParameterType">Request Parameters Type</label>
                    <select id="BodyParameterType" name="BodyParameterType" @change="onBodyParameterTypeChange" class="form-control" v-model="job.BodyParameterType">
                        <option value="">Please select</option>
                        <option :disabled="job.HttpMethodGet && item.Value === 'Json'" v-for="(item, index) in bodyParameterTypes" :key="index" :value="item.Value">{{ item.Text }}</option>
                    </select>
                </div>

                <div class="form-group table-group" v-show="job.JobType === 'WebRequest' && (job.BodyParameterType ==='Json' || job.BodyParameterType ==='FormUrlEncoded'  || job.BodyParameterType ==='FormData')">
                    <input type="hidden" id="BodyParameters" name="BodyParameters" v-model="job.BodyParameters">
                    <div id="bodyParametersJsonEditor"></div>
                </div>


                <div class="form-group table-group" v-show="job.JobType === 'WebRequest' && (job.BodyParameterType ==='Xml' || job.BodyParameterType ==='PlainText' )">
                    <label for="bodyParameterXmlOrText">Body Parameters</label>
                    <textarea @change="bodyParameterXmlOrTextOnChange" class="form-control" rows="10" type="hidden" id="bodyParameterXmlOrText" name="bodyParameterXmlOrText" v-model="bodyParameterXmlOrText"></textarea>
                </div>

                <div class="form-group" v-show="errors.length > 0">
                    <b style="color:red">Please correct the following error(s):</b>
                    <ul>
                        <li v-for="error in errors" :key="error" style="color:red">{{ error }}</li>
                    </ul>
                </div>
            </form>
        </template>
        <template v-slot:footer>
            <button :disabled="isInProgress" v-if="job.Guid !== ''" class="btn btn-primary" @click="addJob(true)">
                <i class="fas fa-clone"></i>
                Save As
            </button>
            <button :disabled="isInProgress" class="btn btn-success" @click="addJob(false)">
                <i class="fas fa-save"></i>
                Save
            </button>
        </template>
    </modal>





    <div class="row">
        <div class="col-md-12">

            <h1 id="page-title" class="page-header">Recurring Jobs Manager </h1>

            <div class="js-jobs-list">

                <div class="btn-toolbar btn-toolbar-top">
                    <button type="button" class="btn btn-sm btn-primary" @click="OpenModal">
                        <span class="glyphicon glyphicon-plus"></span>
                        Add New Job
                    </button>
                    <button type="button" class="btn btn-sm btn-danger" @click="deleteSelectedJobs" :disabled="selectedJobIds.length === 0">
                        <span class="glyphicon glyphicon-trash"></span>
                        Delete Selected Jobs
                    </button>
                    <button type="button" class="btn btn-sm btn-success" @click="startSelectedJobs" :disabled="selectedJobIds.length === 0">
                        <span class="glyphicon glyphicon-play"></span>
                        Start Selected Jobs
                    </button>
                    <button type="button" class="btn btn-sm btn-warning" @click="stopSelectedJobs" :disabled="selectedJobIds.length === 0">
                        <span class="glyphicon glyphicon-stop"></span>
                        Stop Selected Jobs
                    </button>

                    <button type="button" class="btn btn-sm btn-light" @click="exportSelectedJobs" :disabled="selectedJobIds.length === 0">
                        <span class="glyphicon glyphicon-export"></span>
                        Export Selected Jobs
                    </button>


                    <button type="button" class="btn btn-sm btn-light" @click="importJobs">
                        <span class="glyphicon glyphicon-import"></span>
                        Import Jobs
                    </button>

                    <input type="file" id="fileInput" accept=".json" style="display: none" @change="handleFileInput">

                    <div class="btn-group paginator pull-right hidden-xs" v-if="getPageCount > 1">
                        <a href="javascript:" :class="{ disabled:  pagination.currentPage === 1 }" @click="clickCallbackPagination(pagination.currentPage - 1)" class="btn btn-default btn-sm ">
                            Prev
                        </a>
                        <a href="javascript:" :class="{ disabled:  pagination.currentPage === getPageCount }" @click="clickCallbackPagination(pagination.currentPage + 1)" class="btn btn-default btn-sm ">
                            Next
                        </a>
                    </div>


                    <div class="btn-group pull-right paginator">
                        <a v-for="(count, index) in paginationOptions"
                           :key="index"
                           :class="['btn btn-sm btn-default', { active: pagination.parPage === count}]"
                           href="javascript:"
                           @click="updatePagination(count)">
                            {{ count }}
                        </a>

                    </div>
                    <div class="btn-toolbar-spacer pull-right hidden-xs"></div>
                    <div class="btn-toolbar-label btn-toolbar-label-sm pull-right hidden-xs">
                        Items per page:
                    </div>
                </div>

                <div class="table-responsive">
                    <input type="text" class="form-control" v-model="searchTerm" placeholder="Search..." />
                    <table id="joblist" class="table">

                        <thead>
                            <tr>
                                <th class="min-width">
                                    <input type="checkbox" :checked="selectedJobIds.length > 0" @change="toggleSelectAll">
                                </th>
                                <th>Actions</th>
                                <th>Id</th>
                                <th>Job Type</th>
                                <th>Cron</th>
                                <th>State</th>
                                <th>Misfire Handling Mode</th>
                                <th>Type / Host Name</th>
                                <th>Method / Path</th>
                                <th>Time Zone</th>
                                <th>Limit Concurrency</th>
                                <th>Max Concurrent Tasks</th>
                                <th>Created</th>
                                <th>Last Execution</th>
                                <th>Next Execution</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="js-jobs-list-row" v-for="job in getItems" :key="job.Id">
                                <td rowspan="1">

                                    <input type="checkbox"
                                           :value="job.Id"
                                           class="js-jobs-list-checkbox"
                                           v-model="selectedJobIds">


                                    {{selectedJobs}}

                                </td>
                                <td>
                                    <button type="button" title="Edit Job" class="btn btn-warning" style="width:24px;height:24px; padding-top: 10px; margin-right: 5px;" @click="GetJob(job.Id)">
                                        <i style="margin-top: -9px; position: absolute; margin-left: -6px; zoom: 1.2;" class="fas fa-edit"></i>
                                    </button>
                                </td>
                                <td class="word-break ">{{ job.Id }}</td>
                                <td :class="job.JobType">{{ job.JobType }}</td>
                                <td class="min-width min-width-125p ">
                                    <code class="cron-badge">
                                        {{ job.Cron }}
                                    </code>

                                </td>

                                <td class="word-break ">
                                    <span :class="{'label label-success': job.JobState == 'Running', 'label label-danger': job.JobState == 'Stopped'}">
                                        {{ job.JobState }}
                                    </span>
                                </td>

                                <td :style="{color:stringToColor(job.MisfireHandlingMode)}" class="word-break ">{{ job.MisfireHandlingMode }}</td>

                                <td class="word-break ">{{ job.JobType === 'WebRequest' ? job.HostName : job.Type }}</td>
                                <td class="word-break ">{{ job.JobType === 'WebRequest' ? job.UrlPath : job.Method }}</td>
                                <td :style="{color:stringToColor(job.TimeZoneId)}" class="word-break ">{{ job.TimeZoneId }}</td>
                                <td :style="{color:stringToColor(job.LimitConcurrency == true ? 'Yes' : 'No')}" class="word-break ">{{ job.LimitConcurrency == true ? 'Yes' : 'No' }}</td>
                                <td class="word-break ">{{ job.MaxConcurrentTasks }}</td>
                                <td class="word-break ">{{ job.CreatedAt }}</td>
                                <td class="word-break ">{{ job.LastExecution }}</td>
                                <td class="word-break ">{{ job.NextExecution }}</td>

                            </tr>

                        </tbody>
                    </table>



                </div>



                <div class="btn-toolbar">

                    <div class="btn-group paginator" v-if="getPageCount > 1">
                        <a href="javascript:"
                           class="btn btn-default"
                           :class="{ disabled: pagination.currentPage === 1 }"
                           @click="clickCallbackPagination(pagination.currentPage - 1)">
                            Prev
                        </a>
                        <a v-for="page in getPageCount"
                           :key="page"
                           href="javascript:"
                           class="btn btn-default"
                           :class="{ active:  pagination.currentPage === page }"
                           @click="clickCallbackPagination(page)">
                            {{ page }}
                        </a>
                        <a href="javascript:"
                           class="btn btn-default"
                           :class="{ disabled:  pagination.currentPage === getPageCount }"
                           @click="clickCallbackPagination(pagination.currentPage + 1)">
                            Next
                        </a>

                    </div>
                    <div class="btn-toolbar-spacer"></div>
                    <div class="btn-toolbar-label">
                        Total items: {{jobs.length}}
                    </div>
                </div>

            </div>


        </div>
    </div>

</div>

<script>



    const { ref, computed, createApp, nextTick, use } = Vue;



    const ModalComponent = {
        template: '#modal-template',
        methods: {
            closeModal() {
                this.$emit('close');
            }
        }
    };

    const app = createApp({
        components: {
            'modal': ModalComponent

        },
        setup() {
            const selectedJobIds = ref([]);
            const title = ref('Add New Job');
            const jobs = ref(null);
            const bodyParameterXmlOrText = ref('');
            const showModal = ref(false);
            const errors = ref([]);
            const timeZones = ref([]);
            const jobTypes = ref([]);
            const bodyParameterTypes = ref([]);
            const assemblyTypes = ref([]);
            const assemblyTypeMethods = ref([]);
            const httpMethods = ref([]);
            const misfireHandlingModes = ref([]);
            const methodParametersJsonEditor = ref(null);
            const headerParametersJsonEditor = ref(null);
            const bodyParametersJsonEditor = ref(null);
            const methodParametersIsExist = ref(false);
            const LimitConcurrency = ref(false);
            const MaxConcurrentTasks = ref(1);
            const isInProgress = ref(false);
            const searchTerm = ref('');
            const job = ref({
                Id: '',
                Guid: '',
                Cron: '',
                JobType: '',
                Type: '',
                Method: '',
                HttpMethod: '',
                BodyParameterType: '',
                MisfireHandlingMode: '',
                BodyParameters: '',
                HeaderParameters: '',
                HostName: '',
                UrlPath: '',
                JobState: '',
                NextExecution: '',
                LastJobId: '',
                LastJobState: '',
                LastExecution: '',
                CreatedAt: '',
                Removed: false,
                LimitConcurrency: false,
                MaxConcurrentTasks: 1,
                TimeZoneId: '',
                Error: '',
                MethodParameters: ''
            });
            const pagination = ref({
                parPage: 10,
                currentPage: 1
            });
            const paginationOptions = ref([10, 20, 50, 100, 500, 1000, 5000]);
            const selectedJobType = ref('');
            const headerCount = ref(0);

            const generateUUID = () => {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0,
                        v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            };

            const initBodyParametersJsonEditor = () => {
                Vue.nextTick(() => {
                    const element = document.getElementById('bodyParametersJsonEditor');

                    if (bodyParametersJsonEditor.value)
                        bodyParametersJsonEditor.value.destroy();


                    switch (job.value.BodyParameterType) {

                        case "Json":

                            bodyParametersJsonEditor.value = new JSONEditor(element, {
                                schema: {
                                    "type": "object",
                                    "title": "Body Parameters"

                                },
                                iconlib: 'fontawesome5',
                                object_layout: 'grid',
                                show_errors: 'interaction',
                                theme: 'bootstrap5',
                                remove_button_labels: true,
                                no_additional_properties: false,
                                enable_array_copy: false,
                                disable_properties: false,
                                array_controls_top: true,
                                disable_array_reorder: true,
                                disable_collapse: true,
                                disable_edit_json: false
                            });


                            break;
                        case "FormUrlEncoded":

                            bodyParametersJsonEditor.value = new JSONEditor(element, {
                                schema: {
                                    "type": "array",
                                    "title": "Query Parameters",
                                    "items": {
                                        "type": "object",
                                        "title": "Parameter",
                                        "properties": {
                                            "Name": {
                                                "title": "Key",
                                                "type": "string",
                                            },
                                            "Value": {
                                                "title": "Value",
                                                "type": "string"
                                            }
                                        },
                                        "required": ["Name", "Value"]
                                    }
                                },
                                iconlib: 'fontawesome5',
                                object_layout: 'grid',
                                show_errors: 'interaction',
                                theme: 'bootstrap5',
                                remove_button_labels: true,
                                no_additional_properties: false,
                                enable_array_copy: false,
                                disable_properties: false,
                                array_controls_top: true,
                                disable_array_reorder: true,
                                disable_collapse: true,
                                disable_edit_json: false
                            });


                            break;

                        case "FormData":

                            bodyParametersJsonEditor.value = new JSONEditor(element, {
                                schema: {
                                    "type": "array",
                                    "title": "Body Parameters",
                                    "items": {
                                        "type": "object",
                                        "title": "Parameter",
                                        "properties": {
                                            "Name": {
                                                "title": "Key",
                                                "type": "string",
                                            },
                                            "Value": {
                                                "title": "Value",
                                                "type": "string"
                                            },
                                            "ContentType": {
                                                "title": "Content Type",
                                                "type": "string"
                                            }
                                        },
                                        "required": ["Name", "Value", "ContentType"]
                                    }
                                },
                                iconlib: 'fontawesome5',
                                object_layout: 'grid',
                                show_errors: 'interaction',
                                theme: 'bootstrap5',
                                remove_button_labels: true,
                                no_additional_properties: false,
                                enable_array_copy: false,
                                disable_properties: false,
                                array_controls_top: true,
                                disable_array_reorder: true,
                                disable_collapse: true,
                                disable_edit_json: false
                            });


                            break;
                    }
                    if (bodyParametersJsonEditor.value) {

                        bodyParametersJsonEditor.value.on('change', () => {

                            job.value.BodyParameters = JSON.stringify(parseMultipleSerializedJSON(bodyParametersJsonEditor.value.getValue()));
                        });

                        bodyParametersJsonEditor.value.on('ready', () => {

                            var params = parseMultipleSerializedJSON(job.value.BodyParameters);

                            if (params !== null) {
                                bodyParametersJsonEditor.value.setValue(params);
                                checkJsonEditorProperties("bodyParametersJsonEditor");

                            }

                        });
                    }


                });
            };

            const parseMultipleSerializedJSON = (jsonString) => {
                let parsedObject = jsonString;

                while (typeof parsedObject === 'string') {
                    try {
                        parsedObject = JSON.parse(parsedObject);

                    } catch (error) {

                        return null;
                    }
                }

                return parsedObject;
            };

            const initHeaderParametersJsonEditor = () => {
                Vue.nextTick(() => {
                    const element = document.getElementById('headerParametersJsonEditor');



                    if (headerParametersJsonEditor.value)
                        headerParametersJsonEditor.value.destroy();

                    headerParametersJsonEditor.value = new JSONEditor(element, {
                        schema: {
                            "type": "array",
                            "title": "Header Parameters",
                            "items": {
                                "type": "object",
                                "title": "Parameter",
                                "properties": {
                                    "Name": {
                                        "title": "Key",
                                        "type": "string",
                                    },
                                    "Value": {
                                        "title": "value",
                                        "type": "string"
                                    }
                                },
                                "required": ["Name", "Value"]
                            }
                        },
                        iconlib: 'fontawesome5',
                        object_layout: 'grid',
                        show_errors: 'interaction',
                        theme: 'bootstrap5',
                        remove_button_labels: true,
                        no_additional_properties: true,
                        enable_array_copy: false,
                        disable_properties: false,
                        array_controls_top: true,
                        disable_array_reorder: true,
                        disable_collapse: true,
                        disable_edit_json: false
                    });

                    headerParametersJsonEditor.value.on('change', () => {

                        job.value.HeaderParameters = JSON.stringify(parseMultipleSerializedJSON(headerParametersJsonEditor.value.getValue()));
                    });

                    headerParametersJsonEditor.value.on('ready', () => {

                        var params = parseMultipleSerializedJSON(job.value.HeaderParameters);

                        if (params !== null) {
                            headerParametersJsonEditor.value.setValue(params);
                            checkJsonEditorProperties("headerParametersJsonEditor");

                        }

                    });


                });


            };

            const onJobTypeChange = (e) => {
                job.value.JobType = e.target.value;

                if (job.value.JobType == "WebRequest") {

                    initHeaderParametersJsonEditor();

                }
            };

            const onBodyParameterTypeChange = (e) => {

                job.value.BodyParameterType = e.target.value;

                initBodyParametersJsonEditor();
            };

            const bodyParameterXmlOrTextOnChange = (e) => {

                job.BodyParameters = e.target.value;
            };

            const onClassChange = (e) => {
                job.value.Type = e.target.value;
                assemblyTypeMethods.value = [];
                getAssemblyTypeMethods();
            };

            const addJob = (clone) => {

                if (clone === true) {
                    var newGuid = generateUUID();
                    document.getElementById("Guid").value = newGuid;
                    job.value.Guid = newGuid;
                    SaveJob(job.value);
                }
                else {

                    SaveJob(job.value);
                }

            };


            const GetJobs = () => {
                axios.get('job-manager/get-jobs')
                    .then(res => (jobs.value = res.data))
                    .catch(error => console.error('Error fetching jobs:', error));
            };

            const updatePagination = (count) => {
                pagination.value.parPage = count;
                pagination.value.currentPage = 1;
            };
            const onHttpMethodChange = (e) => {


                job.value.HttpMethod = e.target.value;
                job.value.BodyParameterType = 'None';

                getBodyParameterTypes();
            };
            const GetJob = (_Id) => {
                title.value = 'Edit Job';
                axios.get('job-manager/get-job?Id=' + _Id).then(response => {
                    if (response.data != null) {
                        showModal.value = true;
                        const jobData = response.data.Object;
                        job.value = { ...job.value, ...jobData };




                        switch (job.value.BodyParameterType) {
                            case "Xml":
                            case "PlainText":
                                bodyParameterXmlOrText.value = job.value.BodyParameters;
                                break;
                        }

                        switch (job.value.JobType) {

                            case "MethodCall":
                                getAssemblyTypeMethods();
                                break;

                            case "WebRequest":
                                getBodyParameterTypes();
                                initHeaderParametersJsonEditor();
                                initBodyParametersJsonEditor();
                                break;
                        }


                        console.info("JOB", job.value);

                    }
                }).catch(e => {
                    console.log(e);
                });
            };


            const toggleSelectAll = (e) => {

                if (!e.target.checked) {
                    selectedJobIds.value = [];
                } else {
                    selectedJobIds.value = jobs.value.map(job => job.Id);
                }


            };

            const SaveJob = (job) => {
                if (checkForm()) {

                    const formData = new FormData(document.getElementById('formJob'));
                    isInProgress.value = true;

                    // Send a POST request with the FormData object
                    axios.post('job-manager/update-jobs', formData)
                        .then(response => {
                            isInProgress.value = false;

                            selectedJobIds.value = [];
                            closeModal();
                            GetJobs();
                        })
                        .catch(e => {
                            isInProgress.value = false;
                            showModal.value = false;

                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: e.response.data.Message,
                                confirmButtonText: 'OK'
                            });
                        });

                }
            };

            const getTimeZones = () => {
                axios.get('job-manager/get-time-zones').then(response => {
                    timeZones.value = response.data;
                }).catch(e => {
                    console.log(e);
                });
            };


            const getAssemblyTypeMethodJsonSchema = () => {

                if (job.value.Type != '' && job.value.Method != '') {

                    axios.get('job-manager/get-current-assembly-type-method-json-schema?Type=' + job.value.Type + '&Method=' + job.value.Method).then(response => {
                        Vue.nextTick(() => {

                            methodParametersIsExist.value = isValidJson(response.data.Schema);

                            if (!methodParametersIsExist.value) {

                                return;
                            }

                            if (methodParametersJsonEditor.value)
                                methodParametersJsonEditor.value.destroy();

                            methodParametersJsonEditor.value = new JSONEditor(document.getElementById('methodParametersJsonEditor'), {

                                schema: JSON.parse(response.data.Schema),
                                iconlib: 'fontawesome5',
                                object_layout: 'normal',
                                show_errors: 'interaction',
                                theme: 'bootstrap5',
                                remove_button_labels: true,
                                no_additional_properties: true,
                                enable_array_copy: false,
                                disable_properties: false,
                                array_controls_top: true,
                                disable_array_reorder: true,
                                disable_collapse: false,
                                disable_edit_json: false
                            });
                            methodParametersJsonEditor.value.on('change', () => {

                                job.value.MethodParameters = JSON.stringify(methodParametersJsonEditor.value.getValue());
                            });

                            methodParametersJsonEditor.value.on('ready', () => {

                                var params = parseMultipleSerializedJSON(job.value.MethodParameters);

                                if (params !== null) {
                                    methodParametersJsonEditor.value.setValue(params);
                                    checkJsonEditorProperties("methodParametersJsonEditor");
                                }


                            });
                        });


                    }).catch(e => {

                        methodParametersIsExist.value = false;
                        console.log(e);
                    });
                }

            };

            const getMisfireHandlingModes = () => {
                axios.get('job-manager/get-misfire-handling-modes').then(response => {
                    misfireHandlingModes.value = response.data;
                }).catch(e => {
                    console.log(e);
                });
            };

            const gethttpMethods = () => {
                axios.get('job-manager/get-http-methods').then(response => {
                    httpMethods.value = response.data;
                }).catch(e => {
                    console.log(e);
                });
            };
            const startSelectedJobs = () => {

                Swal.fire({
                    title: 'Are you sure?',
                    text: 'Do you want to start the selected ' + selectedJobIds.value.length + ' jobs?',
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: 'Yes, start them!',
                    cancelButtonText: 'No, cancel'
                }).then((result) => {
                    if (result.value) {


                        axios.get('job-manager/job-agent?SelectedJobs=' + selectedJobIds.value.join('|') + "&Action=Start").then(response => {

                            selectedJobIds.value = [];

                            closeModal();

                            GetJobs();

                        }).catch(e => {

                            showModal.value = false;

                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: e.response.data.Message,
                                confirmButtonText: 'OK'
                            });
                        });

                    }
                });



            };
            const stopSelectedJobs = () => {


                Swal.fire({
                    title: 'Are you sure?',
                    text: 'Do you want to stop the selected ' + selectedJobIds.value.length + ' jobs?',
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Yes, stop them!',
                    cancelButtonText: 'No, cancel'
                }).then((result) => {
                    if (result.value) {

                        axios.get('job-manager/job-agent?SelectedJobs=' + selectedJobIds.value.join('|') + "&Action=Stop").then(response => {

                            console.info("stopSelectedJobs", response);

                            selectedJobIds.value = [];

                            closeModal();

                            GetJobs();


                        }).catch(e => {

                            showModal.value = false;

                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: e.response.data.Message,
                                confirmButtonText: 'OK'
                            });
                        });

                    }
                });

            };

            const handleFileInput = (handlefile) => {

                const file = handlefile.target.files[0];

                if (file) {

                    const reader = new FileReader();

                    reader.onload = (handlefileloaded) => {

                        const content = handlefileloaded.target.result;

                        try {

                            var jobItems = JSON.parse(content);

                            Swal.fire({
                                title: 'Import Jobs',
                                text: 'Do you want to import ' + jobItems.length + ' jobs?',
                                icon: 'question',
                                showCancelButton: true,
                                confirmButtonText: 'Yes, import them!',
                                cancelButtonText: 'No, cancel'
                            }).then((result) => {
                                if (result.value) {



                                    const formData = new FormData();
                                    formData.append('SelectedJobs', content);
                                    formData.append('Action', 'Import');
                                    axios.post('job-manager/job-export-import', formData, {
                                        headers: {
                                            'Content-Type': 'multipart/form-data'
                                        }
                                    })
                                        .then(response => {
                                            selectedJobIds.value = [];
                                            closeModal();
                                            GetJobs();
                                        })
                                        .catch(e => {
                                            showModal.value = false;
                                            Swal.fire({
                                                title: 'Error!',
                                                icon: 'error',
                                                text: e.response.data.Message,
                                                confirmButtonText: 'OK'
                                            });
                                        });


                                }
                            });


                        } catch (parseError) {
                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: 'Invalid json file!',
                                confirmButtonText: 'OK'
                            });
                        }



                    };

                    reader.readAsText(file);
                }

            };

            const importJobs = () => {

                console.info("Import jobs clicked!");
                document.getElementById("fileInput").value = "";
                document.getElementById("fileInput").click();

            };

            const exportSelectedJobs = () => {


                Swal.fire({
                    title: 'Export Jobs',
                    text: 'Do you want to export the selected ' + selectedJobIds.value.length + ' jobs?',
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: 'Yes, export them!',
                    cancelButtonText: 'No, cancel'
                }).then((result) => {
                    if (result.value) {

                        axios.get('job-manager/job-export-import?SelectedJobs=' + selectedJobIds.value.join('|') + "&Action=Export").then(response => {

                            console.info("exportSelectedJobs", response);

                            selectedJobIds.value = [];

                            closeModal();

                            const now = new Date();
                            const year = now.getFullYear();
                            const month = String(now.getMonth() + 1).padStart(2, '0');
                            const day = String(now.getDate()).padStart(2, '0');
                            const hours = String(now.getHours()).padStart(2, '0');
                            const minutes = String(now.getMinutes()).padStart(2, '0');
                            const fileName = `Exported-Jobs_${year}-${month}-${day}_${hours}-${minutes}.json`;
                            const blob = new Blob([JSON.stringify(JSON.parse(response.data.Message), null, 2)], { type: 'application/json' });
                            const link = document.createElement('a');
                            const url = window.URL.createObjectURL(blob);
                            link.href = url;
                            link.download = fileName;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(url);




                        }).catch(e => {

                            showModal.value = false;

                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: e.response.data.Message,
                                confirmButtonText: 'OK'
                            });
                        });

                    }
                });

            };

            const deleteSelectedJobs = () => {
                Swal.fire({
                    title: 'Are you sure?',
                    text: 'Do you want to delete the selected ' + selectedJobIds.value.length + ' jobs?',
                    icon: 'warning',
                    showCancelButton: true,
                    confirmButtonText: 'Yes, delete them!',
                    cancelButtonText: 'No, cancel'
                }).then((result) => {
                    if (result.value) {

                        axios.get('job-manager/delete-job?SelectedJobs=' + selectedJobIds.value.join('|')).then(response => {

                            selectedJobIds.value = [];

                            closeModal();

                            GetJobs();


                        }).catch(e => {

                            showModal.value = false;

                            Swal.fire({
                                title: 'Error!',
                                icon: 'error',
                                text: e.response.data.Message,
                                confirmButtonText: 'OK'
                            });
                        });

                    }
                });
            };
            const getBodyParameterTypes = () => {

                axios.get('job-manager/get-body-parameter-types?HttpMethod=' + job.value.HttpMethod).then(response => {
                    bodyParameterTypes.value = response.data;

                }).catch(e => {
                    console.log(e);
                });
            };



            const getJobTypes = () => {
                axios.get('job-manager/get-job-types').then(response => {
                    jobTypes.value = response.data;

                    if (jobTypes.value.length == 1) {
                        job.value.JobType = jobTypes.value[0];
                    }
                }).catch(e => {
                    console.log(e);
                });
            };

            const getAssemblyTypes = () => {
                axios.get('job-manager/get-current-assembly-types').then(response => {
                    assemblyTypes.value = response.data;
                }).catch(e => {
                    console.log(e);
                });
            };

            const getAssemblyTypeMethods = () => {
                axios.get('job-manager/get-current-assembly-type-methods?Type=' + job.value.Type).then(response => {
                    assemblyTypeMethods.value = response.data;


                    getAssemblyTypeMethodJsonSchema();

                }).catch(e => {
                    console.log(e);
                });
            };

            const closeModal = () => {
                job.value = {
                    Id: '',
                    Guid: '',
                    Cron: '',
                    JobType: '',
                    Type: '',
                    Method: '',
                    HttpMethod: '',
                    BodyParameterType: '',
                    MisfireHandlingMode: '',
                    BodyParameters: '',
                    HeaderParameters: '',
                    HostName: '',
                    UrlPath: '',
                    JobState: '',
                    NextExecution: '',
                    LastJobId: '',
                    LastJobState: '',
                    LastExecution: '',
                    CreatedAt: '',
                    Removed: false,
                    LimitConcurrency: false,
                    MaxConcurrentTasks: 1,
                    TimeZoneId: '',
                    Error: '',
                    MethodParameters: ''
                };
                errors.value = [];
                showModal.value = false;
            };

            const OpenModal = () => {
                title.value = 'Add New Job';
                showModal.value = true;
            };

            const checkForm = () => {

                errors.value = [];

                if (!job.value.JobType) {
                    errors.value.push("Please select a Job Type to proceed.");
                }

                if (!job.value.MisfireHandlingMode) {
                    errors.value.push("Please select a Misfire Handling Mode to proceed.");
                }

                if (!job.value.Id) {
                    errors.value.push("Job ID is missing. Please provide a unique identifier for the job.");
                }

                if (jobs.value.some(item => item.Id === job.value.Id && item.Guid !== job.value.Guid)) {
                    errors.value.push("The Job Id already exists. Please provide a unique ID.");
                }

                if (!job.value.Cron) {
                    errors.value.push("Cron expression is missing. Please specify the schedule for the job.");
                }

                if (job.value.LimitConcurrency && job.value.MaxConcurrentTasks <= 0) {

                    errors.value.push("Max Concurrent Tasks must be at least 1.");
                }

                switch (job.value.JobType) {
                    case "WebRequest":
                        if (!job.value.HostName) {
                            errors.value.push("HostName URL is required. Please provide the HostName for the web request.");
                        }
                        if (!job.value.UrlPath) {
                            errors.value.push("HostName Path is required. Please specify the path for the web request.");
                        }
                        if (!job.value.HttpMethod) {
                            errors.value.push("HTTP Method is required. Please select the HTTP method (e.g., GET, POST).");
                        }
                        break;

                    case "MethodCall":
                        if (!job.value.Type) {
                            errors.value.push("Type is required for Method Call jobs. Please select a class.");
                        }
                        if (!job.value.Method) {
                            errors.value.push("Method is required for Method Call jobs. Please select a method.");
                        }
                        break;
                }

                var result = errors.value.length === 0;

                if (!result) {
                    const modalElement = document.querySelector('.modal-scroll');
                    modalElement.scrollTop = modalElement.scrollHeight;
                }
                return result;
            };

            const isValidJson = (str) => {
                return parseMultipleSerializedJSON(str) != null;
            };


            const checkJsonEditorProperties = (id) => {

                const checkboxes = document.querySelectorAll('#' + id + ' input[type="checkbox"].form-check-input');

                checkboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    checkbox.dispatchEvent(new Event('change'));
                });

            };

            const getItems = computed(() => {
                if (!jobs.value) return [];

                var allRecords = jobs.value;

                if (searchTerm.value) {

                    pagination.value.currentPage = 1;

                    const search = searchTerm.value.toLowerCase();

                    allRecords = jobs.value.filter(item => {
                        return Object.keys(item).some(key =>
                            String(item[key]).toLowerCase().includes(search)
                        );
                    });
                }

                let current = pagination.value.currentPage * pagination.value.parPage;

                let start = current - pagination.value.parPage;

                return allRecords.slice(start, current);
            });
            const clickCallbackPagination = (pageNum) => {
                pagination.value.currentPage = Number(pageNum);
            };
            const getPageCount = computed(() => {
                if (!jobs.value) return 0;
                return Math.ceil(jobs.value.length / pagination.value.parPage);
            });


            const hashString = (str) => {

                let hash = 0;
                if (str.length === 0) return hash;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash = hash & hash;
                }
                return hash;
            };

            const stringToColor = (str) => {

                const hash = hashString(str);


                let r = (hash >> 16) & 0xFF;
                let g = (hash >> 8) & 0xFF;
                let b = hash & 0xFF;


                r = Math.min(255, Math.floor(r * 0.75));
                g = Math.min(255, Math.floor(g * 0.75));
                b = Math.min(255, Math.floor(b * 0.75));


                return `rgb(${r}, ${g}, ${b})`;
            };



            return {
                title,
                jobs,
                showModal,
                errors,
                timeZones,
                jobTypes,
                bodyParameterTypes,
                assemblyTypes,
                assemblyTypeMethods,
                httpMethods,
                misfireHandlingModes,
                methodParametersJsonEditor,
                headerParametersJsonEditor,
                bodyParametersJsonEditor,
                job,
                pagination,
                selectedJobType,
                headerCount,
                initBodyParametersJsonEditor,
                initHeaderParametersJsonEditor,
                onJobTypeChange,
                onBodyParameterTypeChange,
                onClassChange,
                addJob,
                stopSelectedJobs,
                exportSelectedJobs,
                importJobs,
                handleFileInput,
                startSelectedJobs,
                GetJobs,
                GetJob,
                SaveJob,
                getTimeZones,
                getAssemblyTypeMethodJsonSchema,
                getMisfireHandlingModes,
                gethttpMethods,
                methodParametersIsExist,
                getBodyParameterTypes,
                getJobTypes,
                getAssemblyTypes,
                getAssemblyTypeMethods,
                closeModal,
                OpenModal,
                checkForm,
                getItems,
                getPageCount,
                selectedJobIds,
                toggleSelectAll,
                clickCallbackPagination,
                paginationOptions,
                updatePagination,
                searchTerm,
                isValidJson,
                parseMultipleSerializedJSON,
                onHttpMethodChange,
                checkJsonEditorProperties,
                deleteSelectedJobs,
                generateUUID,
                stringToColor,
                hashString

            };
        },
        mounted() {


            this.getMisfireHandlingModes();
            this.gethttpMethods();
            this.getAssemblyTypes();
            this.getTimeZones();
            this.getJobTypes();
            this.GetJobs();
        }
    });

    app.mount('#app');
</script>